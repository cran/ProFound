<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Aaron Robotham" />

<meta name="date" content="2018-11-28" />

<title>ProFound: Colour me happy</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">ProFound: Colour me happy</h1>
<h4 class="author"><em>Aaron Robotham</em></h4>
<h4 class="date"><em>2018-11-28</em></h4>



<p>Get the latest version of <strong>ProFound</strong> and <strong>ProFit</strong>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(devtools)
<span class="kw">install_github</span>(<span class="st">'asgr/ProFound'</span>)
<span class="kw">install_github</span>(<span class="st">'ICRAR/ProFit'</span>)</code></pre></div>
<p>Set global evaluate (basically TRUE for GitHub version and FALSE for CRAN):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">evalglobal=<span class="ot">FALSE</span></code></pre></div>
<p>First load the libraries we need:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(ProFound)</code></pre></div>
<pre><code>## Loading required package: FITSio</code></pre>
<pre><code>## Loading required package: magicaxis</code></pre>
<div id="its-a-colourful-life" class="section level2">
<h2>It’s a Colourful Life</h2>
<p>One of the big design considerations when developing <strong>ProFound</strong> was to make colour photometry easy and flexible. This vignette will discuss a couple of ways to tackle it.</p>
<p>First we need some images to do colour photometry on (these are taken from the <strong>ProFound</strong> Robotham et al 2018 paper):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">VISTA_K=<span class="kw">readFITS</span>(<span class="kw">system.file</span>(<span class="st">&quot;extdata&quot;</span>, <span class="st">'VISTA_K.fits'</span>, <span class="dt">package=</span><span class="st">&quot;magicaxis&quot;</span>))
VST_r=<span class="kw">readFITS</span>(<span class="kw">system.file</span>(<span class="st">&quot;extdata&quot;</span>, <span class="st">'VST_r.fits'</span>, <span class="dt">package=</span><span class="st">&quot;magicaxis&quot;</span>))
GALEX_NUV=<span class="kw">readFITS</span>(<span class="kw">system.file</span>(<span class="st">&quot;extdata&quot;</span>, <span class="st">'GALEX_NUV.fits'</span>, <span class="dt">package=</span><span class="st">&quot;magicaxis&quot;</span>))</code></pre></div>
<p>Let’s take a look at the images.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">magimageWCS</span>(VISTA_K)
<span class="kw">magimageWCS</span>(VST_r)
<span class="kw">magimageWCS</span>(GALEX_NUV)</code></pre></div>
<p>It is clear they are pretty well world coordinate system (WCS) aligned, but have very different pixel scales. This creates challenges for decent colour photometry, but there are a few ways to tackle it with the tools in <strong>ProFound</strong>.</p>
<p>First let’s run ProFound in default blind mode on each image and just match the nearby segments (this is the worst approach!)</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pro_K=<span class="kw">profoundProFound</span>(VISTA_K, <span class="dt">magzero=</span><span class="dv">30</span>)
pro_r=<span class="kw">profoundProFound</span>(VST_r, <span class="dt">magzero=</span><span class="dv">0</span>)
pro_NUV=<span class="kw">profoundProFound</span>(GALEX_NUV, <span class="dt">magzero=</span><span class="fl">20.08</span>) <span class="co">#Ugly zero point I know- see Driver et al 2016 Table 3!</span></code></pre></div>
<p><strong>ProFound</strong> has some useful class specific diagnostic plots:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(pro_K)
<span class="kw">plot</span>(pro_r)
<span class="kw">plot</span>(pro_NUV)</code></pre></div>
<p>Do not worry too much about the differnce in the source finding, the point really is doing a catalogue match would return weird results for the bright central galaxy because there are such different blind photometry solutions. So we need to enforce some restrictions to get better colour photometry.</p>
</div>
<div id="image-pixel-warping" class="section level2">
<h2>Image Pixel Warping</h2>
<p>One route is to warp the images onto a common WCS scheme and run <strong>ProFound</strong> in either full segment or bright segment mode. Here we will take the VIKING K-band as our target WCS image.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">VST_r_warpK=<span class="kw">magwarp</span>(VST_r, <span class="dt">header_out=</span>VISTA_K<span class="op">$</span>hdr)
GALEX_NUV_warpK=<span class="kw">magwarp</span>(GALEX_NUV, <span class="dt">header_out=</span>VISTA_K<span class="op">$</span>hdr)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">magimageWCS</span>(VISTA_K)
<span class="kw">magimageWCS</span>(VST_r_warpK)
<span class="kw">magimageWCS</span>(GALEX_NUV_warpK)</code></pre></div>
<p>The images are now interpolated onto a common WCS, where their surface brightness is properly maintained (so we do not gain or lose flux). The small differences below are because the original images did not precisely cover the K-band image WCS.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sum</span>(VST_r<span class="op">$</span>imDat)
<span class="kw">sum</span>(VST_r_warpK<span class="op">$</span>image)

<span class="kw">sum</span>(GALEX_NUV<span class="op">$</span>imDat)
<span class="kw">sum</span>(GALEX_NUV_warpK<span class="op">$</span>image)</code></pre></div>
<p>We can now easily run <strong>ProFound</strong> in matched segment mode, turning the dilation iterations off:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pro_r_warpK=<span class="kw">profoundProFound</span>(VST_r_warpK, <span class="dt">segim=</span>pro_K<span class="op">$</span>segim, <span class="dt">magzero=</span><span class="dv">0</span>, <span class="dt">iters=</span><span class="dv">0</span>)
pro_NUV_warpK=<span class="kw">profoundProFound</span>(GALEX_NUV_warpK, <span class="dt">segim=</span>pro_K<span class="op">$</span>segim, <span class="dt">magzero=</span><span class="fl">20.08</span>, <span class="dt">iters=</span><span class="dv">0</span>)</code></pre></div>
<p>And now check the diagnostics:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(pro_K)
<span class="kw">plot</span>(pro_r_warpK)
<span class="kw">plot</span>(pro_NUV_warpK)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">magplot</span>(pro_NUV_warpK<span class="op">$</span>segstats<span class="op">$</span>mag<span class="op">-</span>pro_K<span class="op">$</span>segstats<span class="op">$</span>mag, pro_r_warpK<span class="op">$</span>segstats<span class="op">$</span>mag<span class="op">-</span>pro_K<span class="op">$</span>segstats<span class="op">$</span>mag, <span class="dt">xlab=</span><span class="st">'NUV-K'</span>, <span class="dt">ylab=</span><span class="st">'r-K'</span>)</code></pre></div>
<p>We can achieve the above in a simple way using the <strong>profoundMultiBand</strong> function, just setting iters_tot=0. This automates many of the fiddly steps and allows for multi band stacking (if desired):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">multi=<span class="kw">profoundMultiBand</span>(<span class="dt">inputlist=</span><span class="kw">list</span>(GALEX_NUV_warpK, VST_r_warpK, VISTA_K), <span class="dt">magzero=</span><span class="kw">c</span>(<span class="fl">20.08</span>,<span class="dv">0</span>,<span class="dv">30</span>), <span class="dt">iters_tot=</span><span class="dv">0</span>, <span class="dt">detectbands=</span><span class="st">'K'</span>, <span class="dt">multibands=</span><span class="kw">c</span>(<span class="st">'NUV'</span>,<span class="st">'r'</span>,<span class="st">'K'</span>))</code></pre></div>
<p>And we can check they really do compute the same results:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">magplot</span>(pro_NUV_warpK<span class="op">$</span>segstats<span class="op">$</span>mag, multi<span class="op">$</span>cat_tot<span class="op">$</span>mag_NUVt, <span class="dt">grid=</span><span class="ot">TRUE</span>)</code></pre></div>
</div>
<div id="oher-colour-outputs" class="section level2">
<h2>Oher Colour Outputs</h2>
<p>You might have noticed that <strong>profoundMultiBand</strong> mentions measuring three different types of photometry: total photometry, bright isophotal colour photometry and grouped segment photometry. Total photometry uses the dilated total photometry segmentation map, whereas the isophotal photometry only uses the brighter segim_orig (pre-dilation) map. Grouped segment photometry is a bit more complicated- it represents the flux for groups of touching segments (either grouped by touching segim_orig or dilated segim, depending on the ‘groupby’ setting in <strong>profoundMultiBand</strong>). In some cases the groups might represent better photometry, e.g. consider the dilated grouped segments (this is like running with tolerance=Inf):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">profoundSegimPlot</span>(multi<span class="op">$</span>pro_detect<span class="op">$</span>image, multi<span class="op">$</span>pro_detect<span class="op">$</span>group<span class="op">$</span>groupim)</code></pre></div>
<p>The three catalogues are included in the list output of <strong>profoundMultiBand</strong>, and are named ‘cat_tot’, ‘cat_col’ and ‘cat_grp’. Mostly the grouped photometry will be the same as the total, since mostly things are not touching pre-dilation:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">magplot</span>(multi<span class="op">$</span>cat_grp<span class="op">$</span>mag_rg, multi<span class="op">$</span>cat_tot[<span class="kw">match</span>(multi<span class="op">$</span>cat_grp<span class="op">$</span>groupID, multi<span class="op">$</span>cat_tot<span class="op">$</span>segID),<span class="st">&quot;mag_rt&quot;</span>], <span class="dt">grid=</span><span class="ot">TRUE</span>, <span class="dt">log=</span><span class="st">''</span>, <span class="dt">xlab=</span><span class="st">'Group Mag'</span>, <span class="dt">ylab=</span><span class="st">'Total Mag'</span>)
<span class="kw">abline</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dt">col=</span><span class="st">'red'</span>)</code></pre></div>
<p>There are two clear outliers, one of which is the central bright source (segment/group ID 1), which in our grouped catalogue has become merged with its neighbouring star (segment ID 3). If we <em>did</em> want to merge this together there is a handy utility function to do so, where ‘groupID_merge’ is a vector of all the groups we prefer over the segmented versions of the photometry (in this case just groupID 1):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">merge_cat=<span class="kw">profoundCatMerge</span>(<span class="dt">segstats=</span>multi<span class="op">$</span>cat_tot, <span class="dt">groupstats=</span>multi<span class="op">$</span>cat_grp, <span class="dt">groupsegID=</span>multi<span class="op">$</span>pro_detect<span class="op">$</span>group<span class="op">$</span>groupsegID, <span class="dt">groupID_merge=</span><span class="dv">1</span>)
multi<span class="op">$</span>cat_tot[<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>,<span class="kw">c</span>(<span class="st">'segID'</span>, <span class="st">'mag_rt'</span>)]
multi<span class="op">$</span>cat_grp[<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>,<span class="kw">c</span>(<span class="st">'groupID'</span>, <span class="st">'mag_rg'</span>)]
merge_cat[<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>,<span class="kw">c</span>(<span class="st">'segID'</span>, <span class="st">'mag_rt'</span>, <span class="st">'origin'</span>)]</code></pre></div>
<p>We gain an origin flag in this new catalogue making it clear what the origin of the photometry is (‘group’ for groupstats, or ‘seg’ for segstats). Notice how in the merged catalogue segment ID 3 has been removed, since it is merged in with segment ID 1 to form groupID=1. All this grouping information is stored in the groupsegID object:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">multi<span class="op">$</span>pro_detect<span class="op">$</span>group<span class="op">$</span>groupsegID[<span class="dv">1</span>,<span class="st">&quot;segID&quot;</span>][[<span class="dv">1</span>]]</code></pre></div>
<p>We might also only want to use segments from the colour catalogue that exist in this new merger catalogue. This is easy to do with base <strong>R</strong>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">merge_cat_col=multi<span class="op">$</span>cat_col[multi<span class="op">$</span>cat_col<span class="op">$</span>segID <span class="op">%in%</span><span class="st"> </span>merge_cat<span class="op">$</span>segID,]</code></pre></div>
<p>These now both have the same number of rows by construction, and sources will appear on the same row, so we can plot comparisons very easily:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">magplot</span>(merge_cat<span class="op">$</span>mag_rt, merge_cat_col<span class="op">$</span>mag_rc, <span class="dt">xlab=</span><span class="st">'Total Mag'</span>, <span class="dt">ylab=</span><span class="st">'Colour Mag'</span>, <span class="dt">grid=</span><span class="ot">TRUE</span>)
<span class="kw">abline</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dt">col=</span><span class="st">'red'</span>)</code></pre></div>
<p>As a note, there is one object that is actually fainter in its dilated total photometry- it is pretty faint, and probably not a good object!</p>
</div>
<div id="segmentation-map-warping" class="section level2">
<h2>Segmentation Map Warping</h2>
<p>The alternative approach is to leave the pixels be, but warp the segmentation map itself to fit a target WCS. Handily there is a function to do exactly this!</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">segim_r=<span class="kw">profoundSegimWarp</span>(<span class="dt">segim_in=</span>pro_K<span class="op">$</span>segim, <span class="dt">header_in=</span>VISTA_K<span class="op">$</span>hdr, <span class="dt">header_out=</span>VST_r<span class="op">$</span>hdr)
segim_NUV=<span class="kw">profoundSegimWarp</span>(<span class="dt">segim_in=</span>pro_K<span class="op">$</span>segim, <span class="dt">header_in=</span>VISTA_K<span class="op">$</span>hdr, <span class="dt">header_out=</span>GALEX_NUV<span class="op">$</span>hdr)</code></pre></div>
<p>We can now run <strong>ProFound</strong> with a warped segmentation map:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pro_r_warpK2=<span class="kw">profoundProFound</span>(VST_r, <span class="dt">segim=</span>segim_r, <span class="dt">magzero=</span><span class="dv">0</span>, <span class="dt">iters=</span><span class="dv">0</span>)
pro_NUV_warpK2=<span class="kw">profoundProFound</span>(GALEX_NUV, <span class="dt">segim=</span>segim_NUV, <span class="dt">magzero=</span><span class="fl">20.08</span>, <span class="dt">iters=</span><span class="dv">0</span>)</code></pre></div>
<p>And now check the diagnostics:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(pro_K)
<span class="kw">plot</span>(pro_r_warpK2)
<span class="kw">plot</span>(pro_NUV_warpK2)</code></pre></div>
<p>Note we cannot now guarantee that we have exactly the same number of segments since some small ones might not even cover a single pixel. This means we need to match back by segID.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">magplot</span>(pro_r_warpK<span class="op">$</span>segstats<span class="op">$</span>mag[<span class="kw">match</span>(pro_r_warpK2<span class="op">$</span>segstats<span class="op">$</span>segID,pro_r_warpK<span class="op">$</span>segstats<span class="op">$</span>segID)], pro_r_warpK2<span class="op">$</span>segstats<span class="op">$</span>mag, <span class="dt">grid=</span><span class="ot">TRUE</span>, <span class="dt">xlab=</span><span class="st">'r Image Warp / mag'</span>, <span class="dt">ylab=</span><span class="st">'r Segim Warp / mag'</span>)
<span class="kw">magplot</span>(pro_NUV_warpK<span class="op">$</span>segstats<span class="op">$</span>mag[<span class="kw">match</span>(pro_NUV_warpK2<span class="op">$</span>segstats<span class="op">$</span>segID,pro_NUV_warpK<span class="op">$</span>segstats<span class="op">$</span>segID)], pro_NUV_warpK2<span class="op">$</span>segstats<span class="op">$</span>mag, <span class="dt">grid=</span><span class="ot">TRUE</span>, <span class="dt">xlab=</span><span class="st">'NUV Image Warp / mag'</span>, <span class="dt">ylab=</span><span class="st">'NUV Segim Warp / mag'</span>)</code></pre></div>
</div>
<div id="better-colours" class="section level2">
<h2>Better colours</h2>
<p>You might want to allow some degree of segmentation map growth (set iters&gt;0) for you target photometry. This is particularly true when the target band PSF is broader than the detection band. Also, you might do better using the brighter part of the segmentation map returned by <strong>ProFound</strong>, i.e. pass segim_orig rather than segim. In this case you will need to adjust your magnitudes for the detection band by the segstat$origfrac value, which gives the flux fraction in the original segment compared to the final one returned. I.e. something like profound$segstat$mag - 2.5*log10(profound$segstat$origfrac).</p>
<p>As you can see, there is a lot of flexibility to how colours can be computed- either in a very static forced mode (as above), or more dynamically to better adapt to the different characteristics of the target band data. This approached has been used to good effect on UV-radio data, so success should be possible with a bit of care and thought.</p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
